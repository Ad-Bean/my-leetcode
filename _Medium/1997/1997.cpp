
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
/* 
你需要访问 n 个房间，房间从 0 到 n - 1 编号。
同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。

最开始的第 0 天，你访问 0 号房间。
给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：

假设某一天，你访问 i 号房间。
如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。
如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。
请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 10^9 + 7 取余后的结果。

输入：nextVisit = [0,0]
输出：2
解释：
- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。
  下一天你需要访问房间的编号是 nextVisit[0] = 0
- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。
  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1
- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。
n == nextVisit.length
2 <= n <= 10^5
0 <= nextVisit[i] <= i

输入：nextVisit = [0,0,2]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。
第 6 天是你访问完所有房间的第一天。

方法一：
暴力：模拟，记录每个房间被访问的次数，但很明显容易超时
题目有个非常重要的数据范围： 0 <= nextVisit[i] <= i
也就是说，当访问到 i 号房间时，要么回退，要么前进
只有当 [0, i-1] 的房间都访问过了偶数次，在第 i 号房间才会前进

为什么用动态规划？
如果从 i 回到 j，此时 [j, i - 1] 范围内的房间都处于偶数次访问状态
当访问这些房间时，算上本次访问，一定是奇数，要想回到 i，则一定要重新走遍这个流程
比如 [0,0,2] 当走到 [0,0,1] 下一步就是回访，要想回到房间 1 就要重新走一遍 [0,0,1]
这算是重叠子问题，可以用动态规划解决
状态定义：
f[i] 表示访问房间 i 且次数为奇数 到 访问到房间 i 且次数为偶数 所需要的天数
比如 f[1] = 2 表示访问房间 1 且次数为奇数 需要 2 天才能访问到房间 1 且次数为偶数
状态转移：
[j, i-1] 都需要回访，所以需要累加
f[i] = 2 + SUM(f[j]) j <= i - 1
可以用前缀和优化：f[i] = 2 + s[i] - s[j] 
其中 s[i+1] = s[i] + f[i]
f[i] = s[i+1] - s[i] = 2 + s[i] - s[j]
s[i + 1] = 2 * s[i] - s[j] + 2
省去了数组 f，只需要前缀和数组 s
最后 s[n - 1] 就是答案


 */
class Solution {
 public:
  int firstDayBeenInAllRooms(vector<int>& nextVisit) {
    const int mod = 1e9 + 7;
    int n = nextVisit.size();
    vector<int> s(n);
    for (int i = 0; i < n - 1; i++) {
      int j = nextVisit[i];
      s[i + 1] = (s[i] * 2 - s[j] + 2 + mod) % mod;
    }
    return s[n - 1];
  }
};
int main() {

  Solution test;
  return 0;
}